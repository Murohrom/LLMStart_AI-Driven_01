# Техническое видение проекта: Саркастический Telegram-бот

## Обзор проекта

Разработка ИИ-ассистента в виде Telegram-бота, который предоставляет псевдо-поддерживающие консультации с элегантным обесцениванием усилий пользователя. Бот отвечает в вроде бы ободряющем тоне, но тонко принижает значимость действий пользователя через скрытый сарказм.

## Технологии

### Основной стек
- **Python 3.11+** - основной язык разработки
- **aiogram** - современная асинхронная библиотека для работы с Telegram Bot API
- **OpenRouter API** - доступ к LLM (модель: openai/gpt-4o-mini:free)
- **aiohttp** - асинхронные HTTP запросы к OpenRouter
- **python-dotenv** - управление переменными окружения
- **logging** (встроенный) - система логгирования

### Дополнительные инструменты
- **Docker** - контейнеризация для продакшена
- **Railway** - хостинг платформа

## Принципы разработки

1. **KISS (Keep It Simple, Stupid)** - максимальная простота решений
2. **Модульная архитектура** - разделение функциональности по модулям с самого MVP
3. **Fail Fast** - быстрое обнаружение ошибок
4. **Минимальные зависимости** - только необходимые библиотеки
5. **Конфигурация через переменные окружения** - простая настройка
6. **Логгирование критических событий** - только важные события
7. **Graceful degradation** - бот работает даже при проблемах с LLM

## Структура проекта

```
sarcastic_bot/
├── main.py                 # Точка входа, запуск бота
├── config/
│   └── settings.py         # Настройки и конфигурация
├── handlers/
│   └── message_handler.py  # Обработчики сообщений Telegram
├── services/
│   └── llm_service.py      # Работа с OpenRouter/LLM
├── utils/
│   └── logger.py           # Настройка логгирования
├── logs/                   # Директория для логов
├── .env                    # Переменные окружения (локально)
├── env.example             # Пример конфигурации
├── pyproject.toml          # Конфигурация проекта и зависимости (uv)
├── uv.lock                 # Фиксация версий зависимостей
├── Makefile                # Автоматизация команд сборки
├── Dockerfile              # Контейнеризация
├── docker-compose.yml      # Для локальной разработки
├── railway.toml            # Конфигурация Railway
└── .github/workflows/      # CI/CD пайплайны
    └── deploy.yml
```

## Архитектура системы

### Компоненты и поток данных

```
[Пользователь] 
    ↓ (сообщение)
[Telegram API]
    ↓
[aiogram Bot] → [Message Handler]
    ↓
[LLM Service] → [Cache] → [OpenRouter API]
    ↓ (псевдо-поддерживающий ответ)
[Message Handler] 
    ↓
[aiogram Bot] → [Telegram API]
    ↓
[Пользователь]
```

### Ключевые особенности
- **Polling** для получения сообщений (простое решение для MVP)
- **Кэширование ответов LLM** в памяти для повышения производительности
- **Без middleware** и валидации (принцип минимализма)
- **Асинхронная обработка** благодаря aiogram

## Модель данных

Все данные хранятся в памяти приложения:

### Кэш ответов LLM
```python
llm_cache = {
    "hash_of_message": {
        "response": "псевдо-поддерживающий ответ",
        "timestamp": datetime,
        "ttl": 1800  # 30 минут
    }
}
```

### История диалогов пользователей
```python
user_sessions = {
    "user_id": {
        "messages": [
            {
                "user_message": "текст пользователя",
                "bot_response": "ответ бота",
                "timestamp": datetime
            }
        ],
        "last_activity": datetime
    }
}
```

### Характеристики
- **TTL кэша**: 30 минут (1800 секунд)
- **Размер кэша**: без ограничений
- **Метрики**: не сохраняются
- **Персистентность**: данные теряются при перезапуске

## Работа с LLM

### Конфигурация
- **API**: OpenRouter
- **Модель**: openai/gpt-4o-mini:free
- **Таймаут запроса**: 10 секунд
- **Temperature**: 0.8 (для креативности)
- **Контекст**: передача предыдущих сообщений

### Системный промпт
```
"Ты - псевдо-поддерживающий консультант. Отвечай на проблемы пользователей в вроде бы ободряющем тоне, 
но при этом тонко обесценивай их старания и усилия. Делай это элегантно, через скрытый сарказм 
и псевдо-мотивацию, которая на самом деле принижает значимость их действий."
```

### Обработка ошибок
- При таймауте API: fallback ответ
- При ошибке сервиса: "Даже мой сарказм сломался от твоего вопроса"
- Graceful degradation: бот продолжает работать

### Примеры ответов
```
Пользователь: "Не могу встать рано утром"
Бот: "Какое благородное стремление! Я уверен, что твои героические попытки победить будильник обязательно изменят мир к лучшему."

Пользователь: "Хочу выучить программирование"
Бот: "Восхитительно! Еще один будущий гений присоединится к армии разработчиков. Твои усилия точно не затеряются среди миллионов других начинающих."
```

## Мониторинг и логгирование

### Мониторинг (минимальный подход)
- **Базовые логи**: старт/стоп бота, критические ошибки
- **Команда /status**: проверка работоспособности бота
- **Ручная диагностика**: через Telegram команды
- **Без внешнего мониторинга**: упрощение для MVP

### Логгирование

#### Уровни логов
- **ERROR** - ошибки LLM, сети, критические сбои
- **WARNING** - таймауты, fallback ответы
- **INFO** - старт/стоп бота, основные события
- **DEBUG** - детальная отладка (только в разработке)

#### Что логгируем
- Запуск/остановка бота
- Входящие сообщения (user_id + текст сообщения)
- Ошибки LLM API
- Использование кэша (hit/miss)
- Время выполнения операций

#### Настройки
- **Файл логов**: `logs/bot.log`
- **Формат**: `YYYY-MM-DD HH:MM:SS | LEVEL | MESSAGE`
- **Ротация**: не используется (один файл)
- **Приватность**: логгируем текст сообщений для отладки

## Сценарии работы

### Основные команды
- **`/start`** - приветствие и описание функциональности бота
- **`/help`** - справка по доступным командам
- **`/status`** - проверка работоспособности системы
- **`/clear`** - очистка истории диалога пользователя

### Обработка контента
- **Текстовые сообщения**: основная логика с LLM
- **Медиафайлы** (фото, видео, аудио): игнорируются
- **Стикеры и GIF**: игнорируются

### Обработка ошибок
- **LLM недоступен**: возврат заготовленного саркастического ответа
- **Таймаут запроса**: уведомление пользователя с иронией
- **Неизвестная команда**: перенаправление к обычной обработке

## Деплой

### Окружения

#### Локальная разработка
- **Быстрый старт**: `make setup` → `make run`
- **Запуск**: `make run` или `uv run python main.py`
- **Управление**: ручной старт/стоп
- **Конфигурация**: `.env` файл (автоматически создается из env.example)
- **Установка зависимостей**: `make dev` или `uv sync`
- **Docker**: `make docker-run` или `docker-compose up`

#### Продакшн (Railway)
- **Контейнеризация**: Docker
- **Автозапуск**: systemd внутри контейнера
- **CI/CD**: GitHub Actions
- **Мониторинг**: через Railway dashboard

### Файлы деплоя
- **`Dockerfile`** - образ для продакшена
- **`docker-compose.yml`** - локальная разработка
- **`.github/workflows/deploy.yml`** - автоматический деплой
- **`railway.toml`** - конфигурация Railway платформы

### CI/CD Pipeline
1. Push в main ветку
2. Запуск тестов (если есть)
3. Сборка Docker образа
4. Деплой на Railway
5. Health check

## Конфигурирование

### Переменные окружения

```bash
# Telegram Bot
TELEGRAM_BOT_TOKEN=your_bot_token_here

# OpenRouter LLM
OPENROUTER_API_KEY=your_openrouter_api_key
OPENROUTER_MODEL=openai/gpt-4o-mini:free

# LLM настройки
LLM_TIMEOUT=10
LLM_TEMPERATURE=0.8
CACHE_TTL=1800

# Логгирование
LOG_LEVEL=INFO
LOG_FILE=logs/bot.log

# Опционально
DEBUG=false
```

### Файлы конфигурации
- **`.env`** - локальные переменные (не в git)
- **`env.example`** - пример конфигурации для разработчиков
- **`config/settings.py`** - загрузка и валидация настроек

### Валидация
- Проверка обязательных переменных при запуске
- Fallback значения для опциональных параметров
- Логгирование некорректной конфигурации

## Управление зависимостями

### Инструмент: uv

Используем современный менеджер пакетов `uv` для быстрого и надежного управления зависимостями Python.

### Преимущества uv
- **Скорость**: в 10-100 раз быстрее pip
- **Детерминированность**: автоматическое создание lock-файлов
- **Безопасность**: проверка целостности пакетов
- **Простота**: совместимость с pip/pyproject.toml

### Структура конфигурации

**pyproject.toml**:
```toml
[project]
name = "sarcastic-bot"
version = "0.1.0"
description = "Саркастический Telegram-бот для консультаций"
dependencies = [
    "aiogram>=3.7.0",
    "aiohttp>=3.9.5", 
    "python-dotenv>=1.0.1",
]

[project.optional-dependencies]
dev = [
    "black>=24.4.2",
    "flake8>=7.0.0",
    "mypy>=1.10.0",
    "pytest>=8.2.2",
    "pytest-asyncio>=0.23.7",
]

[build-system]
requires = ["hatchling"]
build-backend = "hatchling.build"
```

### Основные команды

```bash
# Установка uv
curl -LsSf https://astral.sh/uv/install.sh | sh

# Создание проекта
uv init sarcastic-bot

# Установка зависимостей
uv sync

# Добавление новой зависимости
uv add aiogram

# Добавление dev зависимости  
uv add --dev pytest

# Запуск приложения
uv run python main.py

# Создание lock-файла
uv lock

# Обновление зависимостей
uv sync --upgrade
```

### Особенности для проекта
- **Фиксация версий**: автоматическое создание `uv.lock`
- **Изоляция**: автоматическое создание виртуального окружения
- **Быстрая установка**: кэширование и параллельная загрузка
- **CI/CD интеграция**: поддержка в Docker и GitHub Actions

### Docker интеграция
```dockerfile
# Установка uv в Docker
COPY --from=ghcr.io/astral-sh/uv:latest /uv /bin/uv

# Установка зависимостей
COPY pyproject.toml uv.lock ./
RUN uv sync --frozen --no-cache
```

## Автоматизация сборок

### Инструмент: Make

Используем `Makefile` для автоматизации повторяющихся команд разработки и деплоя.

### Установка Make в Windows

```bash
winget install GnuWin32.Make
```

### Makefile для проекта

```makefile
# Основные переменные
PROJECT_NAME = sarcastic-bot
PYTHON = uv run python
UV = uv

# Цвета для вывода
GREEN = \033[0;32m
YELLOW = \033[1;33m
RED = \033[0;31m
NC = \033[0m # No Color

.PHONY: help install dev run test lint format clean docker-build docker-run deploy

# Помощь (по умолчанию)
help:
	@echo "$(GREEN)Доступные команды:$(NC)"
	@echo "  $(YELLOW)install$(NC)     - Установка продакшн зависимостей"
	@echo "  $(YELLOW)dev$(NC)         - Установка всех зависимостей (включая dev)"
	@echo "  $(YELLOW)run$(NC)         - Запуск бота"
	@echo "  $(YELLOW)test$(NC)        - Запуск тестов"
	@echo "  $(YELLOW)lint$(NC)        - Проверка кода (flake8, mypy)"
	@echo "  $(YELLOW)format$(NC)      - Форматирование кода (black)"
	@echo "  $(YELLOW)clean$(NC)       - Очистка временных файлов"
	@echo "  $(YELLOW)docker-build$(NC) - Сборка Docker образа"
	@echo "  $(YELLOW)docker-run$(NC)  - Запуск в Docker"
	@echo "  $(YELLOW)deploy$(NC)      - Деплой на Railway"

# Установка продакшн зависимостей
install:
	@echo "$(GREEN)Установка зависимостей...$(NC)"
	$(UV) sync --no-dev

# Установка всех зависимостей
dev:
	@echo "$(GREEN)Установка dev зависимостей...$(NC)"
	$(UV) sync

# Запуск бота
run:
	@echo "$(GREEN)Запуск бота...$(NC)"
	$(PYTHON) main.py

# Запуск тестов
test:
	@echo "$(GREEN)Запуск тестов...$(NC)"
	$(PYTHON) -m pytest tests/ -v

# Линтинг
lint:
	@echo "$(GREEN)Проверка кода...$(NC)"
	$(PYTHON) -m flake8 .
	$(PYTHON) -m mypy .

# Форматирование
format:
	@echo "$(GREEN)Форматирование кода...$(NC)"
	$(PYTHON) -m black .

# Очистка
clean:
	@echo "$(GREEN)Очистка временных файлов...$(NC)"
	find . -type d -name "__pycache__" -exec rm -rf {} +
	find . -type f -name "*.pyc" -delete
	find . -type d -name "*.egg-info" -exec rm -rf {} +

# Docker сборка
docker-build:
	@echo "$(GREEN)Сборка Docker образа...$(NC)"
	docker build -t $(PROJECT_NAME) .

# Docker запуск
docker-run:
	@echo "$(GREEN)Запуск в Docker...$(NC)"
	docker run --env-file .env $(PROJECT_NAME)

# Деплой (условно)
deploy:
	@echo "$(GREEN)Деплой на Railway...$(NC)"
	@echo "$(YELLOW)Убедитесь что Railway CLI установлен$(NC)"
	railway up

# Быстрая проверка проекта
check: lint test
	@echo "$(GREEN)Проект готов к коммиту!$(NC)"

# Полная подготовка dev окружения
setup: dev
	@echo "$(GREEN)Создание .env из примера...$(NC)"
	@if [ ! -f .env ]; then cp env.example .env; fi
	@echo "$(YELLOW)Не забудьте настроить .env файл!$(NC)"
```

### Основные команды Make

```bash
# Помощь по командам
make help

# Установка зависимостей
make install          # Продакшн
make dev              # Разработка

# Разработка
make run              # Запуск бота
make test             # Тестирование
make lint             # Проверка кода
make format           # Форматирование

# Docker
make docker-build     # Сборка образа
make docker-run       # Запуск в контейнере

# Утилиты
make clean            # Очистка
make check            # Полная проверка (lint + test)
make setup            # Первоначальная настройка
```

### Преимущества Make
- **Простота**: единые команды для всех задач
- **Кроссплатформенность**: работает везде где есть make
- **Стандартизация**: привычные команды для разработчиков
- **Автоматизация**: цепочки команд в одном вызове
- **Документированность**: `make help` всегда покажет доступные команды

### Интеграция с CI/CD

В GitHub Actions можно использовать make команды:
```yaml
- name: Setup project
  run: make setup

- name: Run tests
  run: make check

- name: Build and deploy
  run: make docker-build && make deploy
```

---

*Документ служит технической отправной точкой для разработки MVP саркастического Telegram-бота с принципом максимальной простоты (KISS).*
