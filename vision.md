# Техническое видение проекта: Саркастический Telegram-бот

## Обзор проекта

Разработка ИИ-ассистента в виде Telegram-бота, который предоставляет псевдо-поддерживающие консультации с элегантным обесцениванием усилий пользователя. Бот отвечает в вроде бы ободряющем тоне, но тонко принижает значимость действий пользователя через скрытый сарказм.

## Технологии

### Основной стек
- **Python 3.11+** - основной язык разработки
- **aiogram** - современная асинхронная библиотека для работы с Telegram Bot API
- **OpenRouter API** - доступ к LLM (модель: openai/gpt-4o-mini:free)
- **aiohttp** - асинхронные HTTP запросы к OpenRouter
- **python-dotenv** - управление переменными окружения
- **logging** (встроенный) - система логгирования

### Дополнительные инструменты
- **Docker** - контейнеризация для продакшена
- **Railway** - хостинг платформа

## Принципы разработки

1. **KISS (Keep It Simple, Stupid)** - максимальная простота решений
2. **Модульная архитектура** - разделение функциональности по модулям с самого MVP
3. **Fail Fast** - быстрое обнаружение ошибок
4. **Минимальные зависимости** - только необходимые библиотеки
5. **Конфигурация через переменные окружения** - простая настройка
6. **Логгирование критических событий** - только важные события
7. **Graceful degradation** - бот работает даже при проблемах с LLM

## Структура проекта

```
sarcastic_bot/
├── main.py                 # Точка входа, запуск бота
├── config/
│   └── settings.py         # Настройки и конфигурация
├── handlers/
│   └── message_handler.py  # Обработчики сообщений Telegram
├── services/
│   └── llm_service.py      # Работа с OpenRouter/LLM
├── utils/
│   └── logger.py           # Настройка логгирования
├── logs/                   # Директория для логов
├── .env                    # Переменные окружения (локально)
├── env.example             # Пример конфигурации
├── requirements.txt        # Python зависимости
├── Dockerfile              # Контейнеризация
├── docker-compose.yml      # Для локальной разработки
├── railway.toml            # Конфигурация Railway
└── .github/workflows/      # CI/CD пайплайны
    └── deploy.yml
```

## Архитектура системы

### Компоненты и поток данных

```
[Пользователь] 
    ↓ (сообщение)
[Telegram API]
    ↓
[aiogram Bot] → [Message Handler]
    ↓
[LLM Service] → [Cache] → [OpenRouter API]
    ↓ (псевдо-поддерживающий ответ)
[Message Handler] 
    ↓
[aiogram Bot] → [Telegram API]
    ↓
[Пользователь]
```

### Ключевые особенности
- **Polling** для получения сообщений (простое решение для MVP)
- **Кэширование ответов LLM** в памяти для повышения производительности
- **Без middleware** и валидации (принцип минимализма)
- **Асинхронная обработка** благодаря aiogram

## Модель данных

Все данные хранятся в памяти приложения:

### Кэш ответов LLM
```python
llm_cache = {
    "hash_of_message": {
        "response": "псевдо-поддерживающий ответ",
        "timestamp": datetime,
        "ttl": 1800  # 30 минут
    }
}
```

### История диалогов пользователей
```python
user_sessions = {
    "user_id": {
        "messages": [
            {
                "user_message": "текст пользователя",
                "bot_response": "ответ бота",
                "timestamp": datetime
            }
        ],
        "last_activity": datetime
    }
}
```

### Характеристики
- **TTL кэша**: 30 минут (1800 секунд)
- **Размер кэша**: без ограничений
- **Метрики**: не сохраняются
- **Персистентность**: данные теряются при перезапуске

## Работа с LLM

### Конфигурация
- **API**: OpenRouter
- **Модель**: openai/gpt-4o-mini:free
- **Таймаут запроса**: 10 секунд
- **Temperature**: 0.8 (для креативности)
- **Контекст**: передача предыдущих сообщений

### Системный промпт
```
"Ты - псевдо-поддерживающий консультант. Отвечай на проблемы пользователей в вроде бы ободряющем тоне, 
но при этом тонко обесценивай их старания и усилия. Делай это элегантно, через скрытый сарказм 
и псевдо-мотивацию, которая на самом деле принижает значимость их действий."
```

### Обработка ошибок
- При таймауте API: fallback ответ
- При ошибке сервиса: "Даже мой сарказм сломался от твоего вопроса"
- Graceful degradation: бот продолжает работать

### Примеры ответов
```
Пользователь: "Не могу встать рано утром"
Бот: "Какое благородное стремление! Я уверен, что твои героические попытки победить будильник обязательно изменят мир к лучшему."

Пользователь: "Хочу выучить программирование"
Бот: "Восхитительно! Еще один будущий гений присоединится к армии разработчиков. Твои усилия точно не затеряются среди миллионов других начинающих."
```

## Мониторинг и логгирование

### Мониторинг (минимальный подход)
- **Базовые логи**: старт/стоп бота, критические ошибки
- **Команда /status**: проверка работоспособности бота
- **Ручная диагностика**: через Telegram команды
- **Без внешнего мониторинга**: упрощение для MVP

### Логгирование

#### Уровни логов
- **ERROR** - ошибки LLM, сети, критические сбои
- **WARNING** - таймауты, fallback ответы
- **INFO** - старт/стоп бота, основные события
- **DEBUG** - детальная отладка (только в разработке)

#### Что логгируем
- Запуск/остановка бота
- Входящие сообщения (user_id + текст сообщения)
- Ошибки LLM API
- Использование кэша (hit/miss)
- Время выполнения операций

#### Настройки
- **Файл логов**: `logs/bot.log`
- **Формат**: `YYYY-MM-DD HH:MM:SS | LEVEL | MESSAGE`
- **Ротация**: не используется (один файл)
- **Приватность**: логгируем текст сообщений для отладки

## Сценарии работы

### Основные команды
- **`/start`** - приветствие и описание функциональности бота
- **`/help`** - справка по доступным командам
- **`/status`** - проверка работоспособности системы
- **`/clear`** - очистка истории диалога пользователя

### Обработка контента
- **Текстовые сообщения**: основная логика с LLM
- **Медиафайлы** (фото, видео, аудио): игнорируются
- **Стикеры и GIF**: игнорируются

### Обработка ошибок
- **LLM недоступен**: возврат заготовленного саркастического ответа
- **Таймаут запроса**: уведомление пользователя с иронией
- **Неизвестная команда**: перенаправление к обычной обработке

## Деплой

### Окружения

#### Локальная разработка
- **Запуск**: `python main.py`
- **Управление**: ручной старт/стоп
- **Конфигурация**: `.env` файл
- **Docker**: `docker-compose up` (опционально)

#### Продакшн (Railway)
- **Контейнеризация**: Docker
- **Автозапуск**: systemd внутри контейнера
- **CI/CD**: GitHub Actions
- **Мониторинг**: через Railway dashboard

### Файлы деплоя
- **`Dockerfile`** - образ для продакшена
- **`docker-compose.yml`** - локальная разработка
- **`.github/workflows/deploy.yml`** - автоматический деплой
- **`railway.toml`** - конфигурация Railway платформы

### CI/CD Pipeline
1. Push в main ветку
2. Запуск тестов (если есть)
3. Сборка Docker образа
4. Деплой на Railway
5. Health check

## Конфигурирование

### Переменные окружения

```bash
# Telegram Bot
TELEGRAM_BOT_TOKEN=your_bot_token_here

# OpenRouter LLM
OPENROUTER_API_KEY=your_openrouter_api_key
OPENROUTER_MODEL=openai/gpt-4o-mini:free

# LLM настройки
LLM_TIMEOUT=10
LLM_TEMPERATURE=0.8
CACHE_TTL=1800

# Логгирование
LOG_LEVEL=INFO
LOG_FILE=logs/bot.log

# Опционально
DEBUG=false
```

### Файлы конфигурации
- **`.env`** - локальные переменные (не в git)
- **`env.example`** - пример конфигурации для разработчиков
- **`config/settings.py`** - загрузка и валидация настроек

### Валидация
- Проверка обязательных переменных при запуске
- Fallback значения для опциональных параметров
- Логгирование некорректной конфигурации

---

*Документ служит технической отправной точкой для разработки MVP саркастического Telegram-бота с принципом максимальной простоты (KISS).*
